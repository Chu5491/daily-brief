## 🧪 코딩 테스트

### 문제

* 제목: 백준 11724 — 연결 요소의 개수
* 링크: [https://www.acmicpc.net/problem/11724](https://www.acmicpc.net/problem/11724?utm_source=chatgpt.com)
* 플랫폼: 백준
* 난이도/언어: Easy\~Medium / Java·Python

### 문제 내용 (요약)

* 핵심 요구사항 3줄:


1. 무방향 그래프에서 **연결 요소(connected components) 개수**를 구한다.
2. 간선 목록으로 **인접 리스트**를 만들고, 미방문 정점에서 **BFS/DFS 1회**마다 카운트를 +1 한다.
3. **고립 정점**(간선이 없는 정점)도 연결 요소 1개로 센다.

* 입출력 형식:
* 입력: 첫째 줄 `N M` (정점, 간선). 다음 `M`줄에 간선의 양 끝점 `u v` (`1 ≤ u, v ≤ N`, `u ≠ v`).
* 출력: 연결 요소의 개수(정수 1개).
* 제약: `1 ≤ N ≤ 1000`, `0 ≤ M ≤ N×(N−1)/2` / 목표 복잡도 O(N+M)

### 출제 의도 / 평가 역량

* 출제자가 요구하는 것: 그래프 모델링 + 도달 가능한 정점 묶음 세기
* 어떤 능력을 테스트하려는가: **BFS/DFS 기본기**, 방문배열 관리, 고립 정점/비연결 그래프 처리, **O(N+M)** 구현 안정성

### 내 풀이 코드 (첫 시도)

```java
// 언어: Java/Python 중 택1 // 실패/부분성공도 OK — 주석으로 접근 전략과 실수 포인트 남기기 
//실패!!!!
```


### 정답/레퍼런스 코드 (간단 주석 첨부 · Java/BFS)

```java
import java.io.*;
import java.util.*;

/**
 * BOJ 11724 - 연결 요소의 개수 (BFS)
 * - 무방향 그래프에서 연결 요소(덩어리) 개수 세기
 * - 시간복잡도: O(N + M)
 */
public class Main {
	static BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
	static StringTokenizer st;
	static List<Integer>[] g;
	static boolean[] vis;

	static String next() throws Exception {
		while (st == null || !st.hasMoreTokens()) st = new StringTokenizer(br.readLine());
		return st.nextToken();
	}

	public static void main(String[] args) throws Exception {
		int N = Integer.parseInt(next());
		int M = Integer.parseInt(next());

		g = new ArrayList[N + 1];
		for (int i = 1; i <= N; i++) g[i] = new ArrayList<>();

		for (int i = 0; i < M; i++) {
			int u = Integer.parseInt(next());
			int v = Integer.parseInt(next());
			g[u].add(v);
			g[v].add(u);
		}

		vis = new boolean[N + 1];
		int ans = 0;

		for (int i = 1; i <= N; i++) {
			if (!vis[i]) {
				bfs(i);
				ans++;
			}
		}
		System.out.println(ans);
	}

	static void bfs(int s) {
		Deque<Integer> q = new ArrayDeque<>();
		vis[s] = true;
		q.add(s);
		while (!q.isEmpty()) {
			int u = q.poll();
			for (int v : g[u]) {
				if (vis[v]) continue;
				vis[v] = true;
				q.add(v);
			}
		}
	}
}
```



---

## ⏱️ 3분 스캐폴딩 카타 로그 (Java)

> “읽기 전이라도 손이 먼저 가게 만드는” 루틴 기록

* **시작 시간**:
* **목표**: 입력/그래프/탐색 **껍데기**를 3분 내 타이핑
* **오늘 결과(성공/실패)**:
* **타자 순서 체크(체크하면 좋음)**
    * `BufferedReader`/`StringTokenizer`/`next()`
    * `List<Integer>[] g`, `boolean[] vis` 선언
    * N,M 파싱 → 인접리스트 초기화
    * 간선 입력(u↔v 양방향 추가)
    * 외곽루프 `for (1..N)` + `bfs/dfs(i)` 호출
    * `bfs()` 또는 `dfs()` 함수 몸체
* **막힌 포인트 (최대 1\~2개)**:
* **내일 개선 1줄**:



---

## 📚 Java 라이브러리 치트시트 (오늘 사용)

* `**java.io.BufferedReader**`
    * 빠른 입력. `readLine()`으로 한 줄 읽기.
    * 보통 `InputStreamReader(System.in)`와 함께 사용.
* `**java.util.StringTokenizer**`
    * 공백/구분자 기준 **토큰 분리**. `hasMoreTokens()` / `nextToken()`
    * `Scanner`보다 빠름(코테에서 선호).
* `**java.util.List**` **/** `**java.util.ArrayList**`
    * **인접 리스트** 구현에 사용. `List<Integer>[] g = new ArrayList[N+1];`
    * 각 인덱스마다 `new ArrayList<>()` 꼭 초기화.
* `**java.util.Deque**` **/** `**java.util.ArrayDeque**`
    * **큐/스택 겸용** 컨테이너.
    * BFS: `add() / poll()` / DFS(반복): `push() / pop()`.
* `**boolean\[\]**`
    * 방문 표시용. 정점 번호가 1..N이면 **N+1** 크기로 생성.
* (옵션) `**StringBuilder**`
    * 출력 누적이 많을 때 `append()`로 모아 한 번에 출력.


